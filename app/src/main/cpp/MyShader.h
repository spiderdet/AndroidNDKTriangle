//
// Created by yunkai.zheng on 4/3/2024.
//

#ifndef ANDROIDNDKTRIANGLE_MYSHADER_H
#define ANDROIDNDKTRIANGLE_MYSHADER_H
const char* vertexShaderSource0 =
        "#version 300 es\n"
        "#define CC_DEVICE_SUPPORT_FLOAT_TEXTURE 1\n"
        "#define CC_DEVICE_MAX_VERTEX_UNIFORM_VECTORS 1024\n"
        "#define CC_DEVICE_MAX_FRAGMENT_UNIFORM_VECTORS 1024\n"
        "#define CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT 0\n"
        "#define CC_PLATFORM_ANDROID_AND_WEBGL 0\n"
        "#define CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES 0\n"
        "#define CC_JOINT_UNIFORM_CAPACITY 256\n"
        "#define CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS 97\n"
        "#define CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS 127\n"
        "#define HAS_SECOND_UV 0\n"
        "#define USE_TWOSIDE 0\n"
        "#define IS_ANISOTROPY 0\n"
        "#define USE_VERTEX_COLOR 0\n"
        "#define FIX_ANISOTROPIC_ROTATION_MAP 0\n"
        "#define USE_NORMAL_MAP 0\n"
        "#define USE_INSTANCING 0\n"
        "#define CC_USE_LIGHTMAP 0\n"
        "#define CC_USE_SKINNING 0\n"
        "#define CC_USE_BAKED_ANIMATION 0\n"
        "#define CC_RECEIVE_SHADOW 1\n"
        "#define CC_USE_REFLECTION_PROBE 0\n"
        "#define CC_USE_LIGHT_PROBE 0\n"
        "#define CC_USE_MORPH 0\n"
        "#define CC_FORWARD_ADD 0\n"
        "#define CC_USE_FOG 4\n"
        "#define CC_USE_ACCURATE_FOG 0\n"
        "#define CC_MORPH_TARGET_COUNT 2\n"
        "#define CC_MORPH_TARGET_HAS_POSITION 0\n"
        "#define CC_MORPH_TARGET_HAS_NORMAL 0\n"
        "#define CC_MORPH_TARGET_HAS_TANGENT 0\n"
        "#define CC_MORPH_PRECOMPUTED 0\n"
        "#define CC_USE_REAL_TIME_JOINT_TEXTURE 0\n"
        "#define CC_DISABLE_STRUCTURE_IN_FRAGMENT_SHADER 0\n"
        "#define CC_PIPELINE_TYPE 0\n"
        "#define CC_FORCE_FORWARD_SHADING 0\n"
        "#define CC_ENABLE_CLUSTERED_LIGHT_CULLING 0\n"
        "#define CC_SUPPORT_CASCADED_SHADOW_MAP 1\n"
        "#define CC_USE_IBL 2\n"
        "#define CC_USE_DIFFUSEMAP 2\n"
        "#define USE_ALBEDO_MAP 1\n"
        "#define ALBEDO_UV v_uv\n"
        "#define NORMAL_UV v_uv\n"
        "#define DEFAULT_UV v_uv\n"
        "#define USE_PBR_MAP 0\n"
        "#define USE_OCCLUSION_MAP 0\n"
        "#define USE_EMISSIVE_MAP 0\n"
        "#define EMISSIVE_UV v_uv\n"
        "#define USE_ANISOTROPY_MAP 0\n"
        "#define USE_ALPHA_TEST 0\n"
        "#define ALPHA_TEST_CHANNEL a\n"
        "#define CC_SHADOWMAP_USE_LINEAR_DEPTH 0\n"
        "#define CC_SHADOWMAP_FORMAT 0\n"
        "\n"
        "precision highp float;\n"
        "  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n"
        "  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n"
        "  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n"
        "  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n"
        "#if IS_ANISOTROPY || USE_NORMAL_MAP\n"
        "  #define CC_SURFACES_USE_TANGENT_SPACE 1\n"
        "#endif\n"
        "  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n"
        "#ifndef CC_SURFACES_USE_SECOND_UV\n"
        "  #define CC_SURFACES_USE_SECOND_UV 0\n"
        "#endif\n"
        "#ifndef CC_SURFACES_USE_TANGENT_SPACE\n"
        "  #define CC_SURFACES_USE_TANGENT_SPACE 0\n"
        "#endif\n"
        "#ifndef CC_SURFACES_USE_VERTEX_COLOR\n"
        "  #define CC_SURFACES_USE_VERTEX_COLOR 0\n"
        "#endif\n"
        "#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n"
        "  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n"
        "#endif\n"
        "#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n"
        "  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n"
        "#endif\n"
        "#ifndef CC_SURFACES_USE_LIGHT_MAP\n"
        "  #ifdef CC_USE_LIGHTMAP\n"
        "    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n"
        "  #else\n"
        "    #define CC_SURFACES_USE_LIGHT_MAP 0\n"
        "  #endif\n"
        "#endif\n"
        "#ifndef CC_SURFACES_FLIP_UV\n"
        "  #define CC_SURFACES_FLIP_UV 0\n"
        "#endif\n"
        "#ifndef CC_SURFACES_USE_TWO_SIDED\n"
        "  #define CC_SURFACES_USE_TWO_SIDED 0\n"
        "#endif\n"
        "#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n"
        "  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n"
        "#endif\n"
        "#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n"
        "  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n"
        "#endif\n"
        "#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n"
        "  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n"
        "#endif\n"
        "#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n"
        "  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n"
        "#endif\n"
        "#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n"
        "  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n"
        "#endif\n"
        "#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n"
        "  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n"
        "#endif\n"
        "#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n"
        "  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n"
        "#endif\n"
        "#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n"
        "  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n"
        "#endif\n"
        "#ifndef CC_SURFACES_LIGHTING_TRT\n"
        "  #define CC_SURFACES_LIGHTING_TRT 0\n"
        "#endif\n"
        "#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n"
        "  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n"
        "#endif\n"
        "#ifndef CC_SURFACES_LIGHTING_SHEEN\n"
        "  #define CC_SURFACES_LIGHTING_SHEEN 0\n"
        "#endif\n"
        "#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n"
        "  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n"
        "#endif\n"
        "#ifndef CC_SURFACES_LIGHTING_TT\n"
        "  #define CC_SURFACES_LIGHTING_TT 0\n"
        "#endif\n"
        "#ifndef CC_SURFACES_LIGHTING_SSS\n"
        "  #define CC_SURFACES_LIGHTING_SSS 0\n"
        "#endif\n"
        "#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n"
        "  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_SHEEN || CC_SURFACES_LIGHTING_CLEAR_COAT\n"
        "    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n"
        "  #endif\n"
        "#endif\n"
        "#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n"
        "  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n"
        "#endif\n"
        "#ifndef CC_SURFACES_LIGHTING_USE_MULTIPLE_LAYER_BLEND\n"
        "  #if CC_SURFACES_LIGHTING_CLEAR_COAT\n"
        "    #define CC_SURFACES_LIGHTING_USE_MULTIPLE_LAYER_BLEND 1\n"
        "  #endif\n"
        "#endif\n"
        "#ifndef CC_SURFACES_LIGHTING_USE_MULTIPLE_LAYER_BLEND\n"
        "  #define CC_SURFACES_LIGHTING_USE_MULTIPLE_LAYER_BLEND 0\n"
        "#endif\n"
        "#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n"
        "  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n"
        "#endif\n"
        "#define CC_USE_SURFACE_SHADER 1\n"
        "in vec3 a_position;\n"
        "in vec3 a_normal;\n"
        "in vec2 a_texCoord;\n"
        "#if CC_SURFACES_USE_TANGENT_SPACE\n"
        "  in vec4 a_tangent;\n"
        "#endif\n"
        "#if CC_SURFACES_USE_VERTEX_COLOR\n"
        "  in vec4 a_color;\n"
        "#endif\n"
        "#if CC_SURFACES_USE_SECOND_UV || CC_USE_LIGHTMAP\n"
        "  in vec2 a_texCoord1;\n"
        "#endif\n"
        "#if CC_USE_SKINNING\n"
        "    in vec4 a_joints;\n"
        "  in vec4 a_weights;\n"
        "#endif\n"
        "#if USE_INSTANCING\n"
        "  #if CC_USE_BAKED_ANIMATION\n"
        "    in highp vec4 a_jointAnimInfo;\n"
        "  #endif\n"
        "  in vec4 a_matWorld0;\n"
        "  in vec4 a_matWorld1;\n"
        "  in vec4 a_matWorld2;\n"
        "  #if CC_USE_LIGHTMAP\n"
        "    in vec4 a_lightingMapUVParam;\n"
        "  #endif\n"
        "  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n"
        "    in vec4 a_localShadowBiasAndProbeId;\n"
        "  #endif\n"
        "  #if CC_USE_REFLECTION_PROBE\n"
        "    in vec4 a_reflectionProbeData;\n"
        "  #endif\n"
        "  #if CC_USE_LIGHT_PROBE\n"
        "    in vec4 a_sh_linear_const_r;\n"
        "    in vec4 a_sh_linear_const_g;\n"
        "    in vec4 a_sh_linear_const_b;\n"
        "  #endif\n"
        "#endif\n"
        "#if CC_USE_MORPH\n"
        "    in float a_vertexId;\n"
        "#endif\n"
        "#define QUATER_PI         0.78539816340\n"
        "#define HALF_PI           1.57079632679\n"
        "#define PI                3.14159265359\n"
        "#define PI2               6.28318530718\n"
        "#define PI4               12.5663706144\n"
        "#define INV_QUATER_PI     1.27323954474\n"
        "#define INV_HALF_PI       0.63661977237\n"
        "#define INV_PI            0.31830988618\n"
        "#define INV_PI2           0.15915494309\n"
        "#define INV_PI4           0.07957747155\n"
        "#define EPSILON           1e-6\n"
        "#define EPSILON_LOWP      1e-4\n"
        "#define LOG2              1.442695\n"
        "#define EXP_VALUE         2.71828183\n"
        "#define FP_MAX            65504.0\n"
        "#define FP_SCALE          0.0009765625\n"
        "#define FP_SCALE_INV      1024.0\n"
        "#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n"
        "#define LIGHT_MAP_TYPE_DISABLED 0\n"
        "#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n"
        "#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n"
        "#define REFLECTION_PROBE_TYPE_NONE 0\n"
        "#define REFLECTION_PROBE_TYPE_CUBE 1\n"
        "#define REFLECTION_PROBE_TYPE_PLANAR 2\n"
        "#define REFLECTION_PROBE_TYPE_BLEND 3\n"
        "#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n"
        "#define LIGHT_TYPE_DIRECTIONAL 0.0\n"
        "#define LIGHT_TYPE_SPHERE 1.0\n"
        "#define LIGHT_TYPE_SPOT 2.0\n"
        "#define LIGHT_TYPE_POINT 3.0\n"
        "#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n"
        "#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n"
        "#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n"
        "#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n"
        "#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n"
        "#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n"
        "#define TONE_MAPPING_ACES 0\n"
        "#define TONE_MAPPING_LINEAR 1\n"
        "#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n"
        "#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n"
        "  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n"
        "#endif\n"
        "#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n"
        "  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n"
        "#endif\n"
        "out highp vec3 v_worldPos;\n"
        "out vec4 v_normal;\n"
        "out vec2 v_uv;\n"
        "#if CC_SURFACES_USE_VERTEX_COLOR\n"
        "  out lowp vec4 v_color;\n"
        "#endif\n"
        "#if CC_SURFACES_USE_TANGENT_SPACE\n"
        "  out mediump vec4 v_tangent;\n"
        "#endif\n"
        "#if CC_SURFACES_USE_SECOND_UV\n"
        "  out mediump vec2 v_uv1;\n"
        "#endif\n"
        "#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n"
        "  out mediump vec3 v_luv;\n"
        "#endif\n"
        "#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n"
        "  out mediump vec4 v_shadowBiasAndProbeId;\n"
        "#endif\n"
        "#if CC_USE_REFLECTION_PROBE && USE_INSTANCING\n"
        "  out mediump vec4 v_reflectionProbeData;\n"
        "#endif\n"
        "#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n"
        "  out mediump float v_fogFactor;\n"
        "#endif\n"
        "#if CC_SURFACES_TRANSFER_LOCAL_POS\n"
        "  out highp vec4 v_localPos;\n"
        "#endif\n"
        "#if CC_SURFACES_TRANSFER_CLIP_POS\n"
        "  out highp vec4 v_clipPos;\n"
        "#endif\n"
        "#if CC_USE_LIGHT_PROBE\n"
        "  #if USE_INSTANCING\n"
        "    out mediump vec4 v_sh_linear_const_r;\n"
        "    out mediump vec4 v_sh_linear_const_g;\n"
        "    out mediump vec4 v_sh_linear_const_b;\n"
        "  #endif\n"
        "#endif\n"
        "#define VSOutput_worldPos v_worldPos\n"
        "#define VSOutput_worldNormal v_normal.xyz\n"
        "#define VSOutput_faceSideSign v_normal.w\n"
        "#define VSOutput_texcoord v_uv\n"
        "#if CC_SURFACES_USE_VERTEX_COLOR\n"
        "  #define VSOutput_vertexColor v_color\n"
        "#endif\n"
        "#if CC_SURFACES_USE_TANGENT_SPACE\n"
        "  #define VSOutput_worldTangent v_tangent.xyz\n"
        "  #define VSOutput_mirrorNormal v_tangent.w\n"
        "#endif\n"
        "#if CC_SURFACES_USE_SECOND_UV\n"
        "  #define VSOutput_texcoord1 v_uv1\n"
        "#endif\n"
        "#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n"
        "  #define VSOutput_lightMapUV v_luv\n"
        "#endif\n"
        "#if CC_RECEIVE_SHADOW\n"
        "  #define VSOutput_shadowBias v_shadowBiasAndProbeId.xy\n"
        "#endif\n"
        "#if CC_USE_REFLECTION_PROBE\n"
        "  #define VSOutput_reflectionProbeId v_shadowBiasAndProbeId.z\n"
        "  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n"
        "    #define VSOutput_reflectionProbeBlendId v_shadowBiasAndProbeId.w\n"
        "  #endif\n"
        "  #if USE_INSTANCING\n"
        "    #define VSOutput_reflectionProbeData v_reflectionProbeData\n"
        "  #endif\n"
        "#endif\n"
        "#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n"
        "  #define VSOutput_fogFactor v_fogFactor\n"
        "#endif\n"
        "#if CC_SURFACES_TRANSFER_LOCAL_POS\n"
        "  #define VSOutput_localPos v_localPos\n"
        "#endif\n"
        "#if CC_SURFACES_TRANSFER_CLIP_POS\n"
        "  #define VSOutput_clipPos v_clipPos\n"
        "#endif\n"
        "struct SurfacesStandardVertexIntermediate\n"
        "{\n"
        "  highp vec4 position;\n"
        "  vec3 normal;\n"
        "#if CC_SURFACES_USE_TANGENT_SPACE\n"
        "  vec4 tangent;\n"
        "#endif\n"
        "#if CC_SURFACES_USE_VERTEX_COLOR\n"
        "  vec4 color;\n"
        "#endif\n"
        "  vec2 texCoord;\n"
        "#if CC_SURFACES_USE_SECOND_UV\n"
        "  vec2 texCoord1;\n"
        "#endif\n"
        "  highp vec4 clipPos;\n"
        "  highp vec3 worldPos;\n"
        "  vec4 worldNormal;\n"
        "  #if CC_SURFACES_USE_TANGENT_SPACE\n"
        "    vec3 worldTangent, worldBinormal;\n"
        "  #endif\n"
        "#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n"
        "  vec4 shadowBiasAndProbeId;\n"
        "#endif\n"
        "#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n"
        "  float fogFactor;\n"
        "#endif\n"
        "#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n"
        "  vec3 lightmapUV;\n"
        "#endif\n"
        "};\n"
        "#if CC_USE_MORPH\n"
        "    int getVertexId() {\n"
        "      return int(a_vertexId);\n"
        "    }\n"
        "#endif\n"
        "layout(std140) uniform CCGlobal {\n"
        "  highp   vec4 cc_time;\n"
        "  mediump vec4 cc_screenSize;\n"
        "  mediump vec4 cc_nativeSize;\n"
        "  mediump vec4 cc_probeInfo;\n"
        "  mediump vec4 cc_debug_view_mode;\n"
        "};\n"
        "layout(std140) uniform CCCamera {\n"
        "  highp   mat4 cc_matView;\n"
        "  highp   mat4 cc_matViewInv;\n"
        "  highp   mat4 cc_matProj;\n"
        "  highp   mat4 cc_matProjInv;\n"
        "  highp   mat4 cc_matViewProj;\n"
        "  highp   mat4 cc_matViewProjInv;\n"
        "  highp   vec4 cc_cameraPos;\n"
        "  mediump vec4 cc_surfaceTransform;\n"
        "  mediump vec4 cc_screenScale;\n"
        "  mediump vec4 cc_exposure;\n"
        "  mediump vec4 cc_mainLitDir;\n"
        "  mediump vec4 cc_mainLitColor;\n"
        "  mediump vec4 cc_ambientSky;\n"
        "  mediump vec4 cc_ambientGround;\n"
        "  mediump vec4 cc_fogColor;\n"
        "  mediump vec4 cc_fogBase;\n"
        "  mediump vec4 cc_fogAdd;\n"
        "  mediump vec4 cc_nearFar;\n"
        "  mediump vec4 cc_viewPort;\n"
        "};\n"
        "layout(std140) uniform CCShadow {\n"
        "  highp mat4 cc_matLightView;\n"
        "  highp mat4 cc_matLightViewProj;\n"
        "  highp vec4 cc_shadowInvProjDepthInfo;\n"
        "  highp vec4 cc_shadowProjDepthInfo;\n"
        "  highp vec4 cc_shadowProjInfo;\n"
        "  mediump vec4 cc_shadowNFLSInfo;\n"
        "  mediump vec4 cc_shadowWHPBInfo;\n"
        "  mediump vec4 cc_shadowLPNNInfo;\n"
        "  lowp vec4 cc_shadowColor;\n"
        "  mediump vec4 cc_planarNDInfo;\n"
        "};\n"
        "highp float decode32 (highp vec4 rgba) {\n"
        "  rgba = rgba * 255.0;\n"
        "  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n"
        "  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n"
        "  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n"
        "  return Sign * exp2(Exponent - 23.0) * Mantissa;\n"
        "}\n"
        "#if !USE_INSTANCING\n"
        "  layout(std140) uniform CCLocal {\n"
        "    highp mat4 cc_matWorld;\n"
        "    highp mat4 cc_matWorldIT;\n"
        "    highp vec4 cc_lightingMapUVParam;\n"
        "    highp vec4 cc_localShadowBias;\n"
        "    highp vec4 cc_reflectionProbeData1;\n"
        "    highp vec4 cc_reflectionProbeData2;\n"
        "    highp vec4 cc_reflectionProbeBlendData1;\n"
        "    highp vec4 cc_reflectionProbeBlendData2;\n"
        "  };\n"
        "#endif\n"
        "void CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n"
        "{\n"
        "  #if USE_INSTANCING\n"
        "    matWorld = mat4(\n"
        "      vec4(a_matWorld0.xyz, 0.0),\n"
        "      vec4(a_matWorld1.xyz, 0.0),\n"
        "      vec4(a_matWorld2.xyz, 0.0),\n"
        "      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n"
        "    );\n"
        "    vec3 scale = 1.0 / vec3(length(a_matWorld0.xyz), length(a_matWorld1.xyz), length(a_matWorld2.xyz));\n"
        "    vec3 scale2 = scale * scale;\n"
        "    matWorldIT = mat4(\n"
        "      vec4(a_matWorld0.xyz * scale2.x, 0.0),\n"
        "      vec4(a_matWorld1.xyz * scale2.y, 0.0),\n"
        "      vec4(a_matWorld2.xyz * scale2.z, 0.0),\n"
        "      vec4(0.0, 0.0, 0.0, 1.0)\n"
        "    );\n"
        "  #else\n"
        "    matWorld = cc_matWorld;\n"
        "    matWorldIT = cc_matWorldIT;\n"
        "  #endif\n"
        "}\n"
        "#if CC_USE_MORPH\n"
        "  layout(std140) uniform CCMorph {\n"
        "    vec4 cc_displacementWeights[15];\n"
        "    vec4 cc_displacementTextureInfo;\n"
        "  };\n"
        "  #if CC_MORPH_TARGET_HAS_POSITION\n"
        "    uniform sampler2D cc_PositionDisplacements;\n"
        "  #endif\n"
        "  #if CC_MORPH_TARGET_HAS_NORMAL\n"
        "    uniform sampler2D cc_NormalDisplacements;\n"
        "  #endif\n"
        "  #if CC_MORPH_TARGET_HAS_TANGENT\n"
        "    uniform sampler2D cc_TangentDisplacements;\n"
        "  #endif\n"
        "  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n"
        "    float pixelIndexF = float(pixelIndex);\n"
        "    float x = mod(pixelIndexF, textureResolution.x);\n"
        "    float y = floor(pixelIndexF / textureResolution.x);\n"
        "    return vec2(x, y);\n"
        "  }\n"
        "  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n"
        "    return (vec2(location.x, location.y) + .5) / textureResolution;\n"
        "  }\n"
        "  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n"
        "      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n"
        "        ivec2 texSize = textureSize(tex, 0);\n"
        "        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n"
        "      }\n"
        "  #else\n"
        "    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n"
        "      int pixelIndex = elementIndex * 4;\n"
        "      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n"
        "      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n"
        "      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n"
        "      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n"
        "      return vec4(\n"
        "        decode32(texture(tex, x)),\n"
        "        decode32(texture(tex, y)),\n"
        "        decode32(texture(tex, z)),\n"
        "        1.0\n"
        "      );\n"
        "    }\n"
        "  #endif\n"
        "  float getDisplacementWeight(int index) {\n"
        "    int quot = index / 4;\n"
        "    int remainder = index - quot * 4;\n"
        "    if (remainder == 0) {\n"
        "      return cc_displacementWeights[quot].x;\n"
        "    } else if (remainder == 1) {\n"
        "      return cc_displacementWeights[quot].y;\n"
        "    } else if (remainder == 2) {\n"
        "      return cc_displacementWeights[quot].z;\n"
        "    } else {\n"
        "      return cc_displacementWeights[quot].w;\n"
        "    }\n"
        "  }\n"
        "  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n"
        "  #if CC_MORPH_PRECOMPUTED\n"
        "    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n"
        "  #else\n"
        "    vec3 result = vec3(0, 0, 0);\n"
        "    int nVertices = int(cc_displacementTextureInfo.z);\n"
        "    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n"
        "      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n"
        "    }\n"
        "    return result;\n"
        "  #endif\n"
        "  }\n"
        "  #if CC_MORPH_TARGET_HAS_POSITION\n"
        "  vec3 getPositionDisplacement(int vertexId) {\n"
        "      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n"
        "  }\n"
        "  #endif\n"
        "  #if CC_MORPH_TARGET_HAS_NORMAL\n"
        "  vec3 getNormalDisplacement(int vertexId) {\n"
        "      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n"
        "  }\n"
        "  #endif\n"
        "  #if CC_MORPH_TARGET_HAS_TANGENT\n"
        "  vec3 getTangentDisplacement(int vertexId) {\n"
        "      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n"
        "  }\n"
        "  #endif\n"
        "  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n"
        "    int vertexId = getVertexId();\n"
        "  #if CC_MORPH_TARGET_HAS_POSITION\n"
        "    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n"
        "  #endif\n"
        "  #if CC_MORPH_TARGET_HAS_NORMAL\n"
        "    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n"
        "  #endif\n"
        "  #if CC_MORPH_TARGET_HAS_TANGENT\n"
        "    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n"
        "  #endif\n"
        "  }\n"
        "  void applyMorph (inout vec4 position) {\n"
        "  #if CC_MORPH_TARGET_HAS_POSITION\n"
        "    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n"
        "  #endif\n"
        "  }\n"
        "#endif\n"
        "#if CC_USE_SKINNING\n"
        "  #if CC_USE_BAKED_ANIMATION\n"
        "    layout(std140) uniform CCSkinningTexture {\n"
        "      highp vec4 cc_jointTextureInfo;\n"
        "    };\n"
        "    layout(std140) uniform CCSkinningAnimation {\n"
        "      highp vec4 cc_jointAnimInfo;\n"
        "    };\n"
        "    uniform highp sampler2D cc_jointTexture;\n"
        "    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n"
        "    {\n"
        "      #if USE_INSTANCING\n"
        "        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n"
        "      #else\n"
        "        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n"
        "      #endif\n"
        "      invSize = cc_jointTextureInfo.w;\n"
        "      highp float tempY = floor(temp * invSize);\n"
        "      x = floor(temp - tempY * cc_jointTextureInfo.x);\n"
        "      y = (tempY + 0.5) * invSize;\n"
        "    }\n"
        "  #else\n"
        "    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n"
        "      uniform highp sampler2D cc_realtimeJoint;\n"
        "    #else\n"
        "      layout(std140) uniform CCSkinning {\n"
        "        highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n"
        "      };\n"
        "    #endif\n"
        "  #endif\n"
        "  #if CC_USE_BAKED_ANIMATION\n"
        "    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n"
        "      mat4 getJointMatrix (float i) {\n"
        "        highp float x, y, invSize;\n"
        "        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n"
        "        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n"
        "        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n"
        "        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n"
        "        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n"
        "      }\n"
        "    #else\n"
        "      mat4 getJointMatrix (float i) {\n"
        "        highp float x, y, invSize;\n"
        "        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n"
        "        vec4 v1 = vec4(\n"
        "          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n"
        "          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n"
        "          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n"
        "          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n"
        "        );\n"
        "        vec4 v2 = vec4(\n"
        "          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n"
        "          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n"
        "          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n"
        "          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n"
        "        );\n"
        "        vec4 v3 = vec4(\n"
        "          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n"
        "          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n"
        "          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n"
        "          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n"
        "        );\n"
        "        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n"
        "      }\n"
        "    #endif\n"
        "  #else\n"
        "    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n"
        "      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n"
        "        mat4 getJointMatrix (float i) {\n"
        "          float x = i;\n"
        "          vec4 v1 = texture(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n"
        "          vec4 v2 = texture(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n"
        "          vec4 v3 = texture(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n"
        "          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n"
        "        }\n"
        "      #else\n"
        "        mat4 getJointMatrix (float i) {\n"
        "         float x = 4.0 * i;\n"
        "          vec4 v1 = vec4(\n"
        "            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n"
        "            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n"
        "            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n"
        "            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n"
        "          );\n"
        "          vec4 v2 = vec4(\n"
        "            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n"
        "            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n"
        "            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n"
        "            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n"
        "          );\n"
        "          vec4 v3 = vec4(\n"
        "            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n"
        "            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n"
        "            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n"
        "            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n"
        "          );\n"
        "          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n"
        "        }\n"
        "      #endif\n"
        "    #else\n"
        "      mat4 getJointMatrix (float i) {\n"
        "        int idx = int(i);\n"
        "        vec4 v1 = cc_joints[idx * 3];\n"
        "        vec4 v2 = cc_joints[idx * 3 + 1];\n"
        "        vec4 v3 = cc_joints[idx * 3 + 2];\n"
        "        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n"
        "      }\n"
        "    #endif\n"
        "  #endif\n"
        "  mat4 skinMatrix () {\n"
        "    vec4 joints = vec4(a_joints);\n"
        "    return getJointMatrix(joints.x) * a_weights.x\n"
        "         + getJointMatrix(joints.y) * a_weights.y\n"
        "         + getJointMatrix(joints.z) * a_weights.z\n"
        "         + getJointMatrix(joints.w) * a_weights.w;\n"
        "  }\n"
        "  void CCSkin (inout vec4 position) {\n"
        "    mat4 m = skinMatrix();\n"
        "    position = m * position;\n"
        "  }\n"
        "  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n"
        "    mat4 m = skinMatrix();\n"
        "    position = m * position;\n"
        "    normal = (m * vec4(normal, 0.0)).xyz;\n"
        "    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n"
        "  }\n"
        "#endif\n"
        "#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n"
        "  #if CC_USE_FOG != 4\n"
        "  #endif\n"
        "#endif\n"
        "layout(std140) uniform Constants {\n"
        "  vec4 tilingOffset;\n"
        "  vec4 albedo;\n"
        "  vec4 albedoScaleAndCutoff;\n"
        "  vec4 pbrParams;\n"
        "  vec4 emissive;\n"
        "  vec4 emissiveScaleParam;\n"
        "  vec4 anisotropyParam;\n"
        "};\n"
        "#define CC_SURFACES_VERTEX_MODIFY_SHADOW_BIAS\n"
        "#define CC_SURFACES_VERTEX_MODIFY_UV\n"
        "void SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n"
        "{\n"
        "  In.texCoord = In.texCoord * tilingOffset.xy + tilingOffset.zw;\n"
        "#if CC_SURFACES_USE_SECOND_UV\n"
        "  In.texCoord1 = In.texCoord1 * tilingOffset.xy + tilingOffset.zw;\n"
        "#endif\n"
        "}\n"
        "#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_POS\n"
        "vec3 SurfacesVertexModifyLocalPos(in SurfacesStandardVertexIntermediate In)\n"
        "{\n"
        "  return vec3(In.position.xyz);\n"
        "}\n"
        "#endif\n"
        "#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_NORMAL\n"
        "#endif\n"
        "#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_TANGENT\n"
        "  #if CC_SURFACES_USE_TANGENT_SPACE\n"
        "  #endif\n"
        "#endif\n"
        "#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_SHARED_DATA\n"
        "void SurfacesVertexModifyLocalSharedData(inout SurfacesStandardVertexIntermediate In)\n"
        "{\n"
        "}\n"
        "#endif\n"
        "#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_POS\n"
        "vec3 SurfacesVertexModifyWorldPos(in SurfacesStandardVertexIntermediate In)\n"
        "{\n"
        "  return In.worldPos;\n"
        "}\n"
        "#endif\n"
        "#ifndef CC_SURFACES_VERTEX_MODIFY_CLIP_POS\n"
        "vec4 SurfacesVertexModifyClipPos(in SurfacesStandardVertexIntermediate In)\n"
        "{\n"
        "  return In.clipPos;\n"
        "}\n"
        "#endif\n"
        "#ifndef CC_SURFACES_VERTEX_MODIFY_UV\n"
        "void SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n"
        "{\n"
        "}\n"
        "#endif\n"
        "#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_NORMAL\n"
        "#endif\n"
        "#ifndef CC_SURFACES_VERTEX_MODIFY_SHADOW_BIAS\n"
        "#endif\n"
        "#ifndef CC_SURFACES_VERTEX_MODIFY_SHARED_DATA\n"
        "void SurfacesVertexModifySharedData(inout SurfacesStandardVertexIntermediate In)\n"
        "{\n"
        "}\n"
        "#endif\n"
        "void CCSurfacesVertexInput(out SurfacesStandardVertexIntermediate In)\n"
        "{\n"
        "  In.position = vec4(a_position, 1.0);\n"
        "  In.normal = a_normal;\n"
        "#if CC_SURFACES_USE_TANGENT_SPACE\n"
        "  In.tangent = a_tangent;\n"
        "#endif\n"
        "#if CC_SURFACES_USE_VERTEX_COLOR\n"
        "  In.color = a_color;\n"
        "#endif\n"
        "  In.texCoord = a_texCoord;\n"
        "#if CC_SURFACES_USE_SECOND_UV\n"
        "  In.texCoord1 = a_texCoord1;\n"
        "#endif\n"
        "}\n"
        "void CCSurfacesVertexOutput(in SurfacesStandardVertexIntermediate In)\n"
        "{\n"
        "  gl_Position = In.clipPos;\n"
        "  VSOutput_worldNormal = In.worldNormal.xyz;\n"
        "  VSOutput_faceSideSign = In.worldNormal.w;\n"
        "  VSOutput_worldPos = In.worldPos;\n"
        "#if CC_SURFACES_USE_TANGENT_SPACE\n"
        "  VSOutput_worldTangent = In.worldTangent.xyz;\n"
        "  VSOutput_mirrorNormal = In.tangent.w > 0.0 ? 1.0 : -1.0;\n"
        "#endif\n"
        "#if CC_SURFACES_USE_VERTEX_COLOR\n"
        "  VSOutput_vertexColor = In.color;\n"
        "#endif\n"
        "  VSOutput_texcoord = In.texCoord;\n"
        "#if CC_SURFACES_USE_SECOND_UV\n"
        "  VSOutput_texcoord1 = In.texCoord1;\n"
        "#endif\n"
        "#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n"
        "  VSOutput_fogFactor = In.fogFactor;\n"
        "#endif\n"
        "#if CC_RECEIVE_SHADOW\n"
        "  VSOutput_shadowBias = In.shadowBiasAndProbeId.xy;\n"
        "#endif\n"
        "#if CC_USE_REFLECTION_PROBE\n"
        "  VSOutput_reflectionProbeId = In.shadowBiasAndProbeId.z;\n"
        "  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n"
        "    VSOutput_reflectionProbeBlendId = In.shadowBiasAndProbeId.w;\n"
        "  #endif\n"
        "  #if USE_INSTANCING\n"
        "    v_reflectionProbeData = a_reflectionProbeData;\n"
        "  #endif\n"
        "#endif\n"
        "#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n"
        "  VSOutput_lightMapUV = In.lightmapUV;\n"
        "#endif\n"
        "#if CC_SURFACES_TRANSFER_LOCAL_POS\n"
        "  VSOutput_localPos = In.position;\n"
        "#endif\n"
        "#if CC_SURFACES_TRANSFER_CLIP_POS\n"
        "  VSOutput_clipPos = In.clipPos;\n"
        "#endif\n"
        "#if CC_USE_LIGHT_PROBE\n"
        "  #if USE_INSTANCING\n"
        "    v_sh_linear_const_r = a_sh_linear_const_r;\n"
        "    v_sh_linear_const_g = a_sh_linear_const_g;\n"
        "    v_sh_linear_const_b = a_sh_linear_const_b;\n"
        "  #endif\n"
        "#endif\n"
        "}\n"
        "void CCSurfacesVertexAnimation(inout SurfacesStandardVertexIntermediate In)\n"
        "{\n"
        "vec4 temp = vec4(0.0);\n"
        "#if CC_USE_MORPH\n"
        "  #if CC_SURFACES_USE_TANGENT_SPACE\n"
        "    applyMorph(In.position, In.normal, In.tangent);\n"
        "  #else\n"
        "    applyMorph(In.position, In.normal, temp);\n"
        "  #endif\n"
        "#endif\n"
        "#if CC_USE_SKINNING\n"
        "  #if CC_SURFACES_USE_TANGENT_SPACE\n"
        "    CCSkin(In.position, In.normal, In.tangent);\n"
        "  #else\n"
        "    CCSkin(In.position, In.normal, temp);\n"
        "  #endif\n"
        "#endif\n"
        "}\n"
        "void CCSurfacesVertexWorldTransform(inout SurfacesStandardVertexIntermediate In)\n"
        "{\n"
        "    mat4 matWorld, matWorldIT;\n"
        "    CCGetWorldMatrixFull(matWorld, matWorldIT);\n"
        "    In.worldPos = (matWorld * In.position).xyz;\n"
        "    In.worldNormal.xyz = normalize((matWorldIT * vec4(In.normal.xyz, 0.0)).xyz);\n"
        "    #if CC_SURFACES_USE_TANGENT_SPACE\n"
        "      In.worldTangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n"
        "      In.worldBinormal = cross(In.worldNormal.xyz, In.worldTangent) * In.tangent.w;\n"
        "    #endif\n"
        "}\n"
        "void CCSurfacesVertexTransformUV(inout SurfacesStandardVertexIntermediate In)\n"
        "{\n"
        "  #if CC_SURFACES_FLIP_UV\n"
        "    In.texCoord = cc_cameraPos.w > 1.0 ? vec2(In.texCoord.x, 1.0 - In.texCoord.y) : In.texCoord;\n"
        "    #if CC_SURFACES_USE_SECOND_UV\n"
        "      In.texCoord1 = cc_cameraPos.w > 1.0 ? vec2(In.texCoord1.x, 1.0 - In.texCoord1.y) : In.texCoord1;\n"
        "    #endif\n"
        "  #endif\n"
        "}\n"
        "out highp vec2 v_clip_depth;\n"
        "void main()\n"
        "{\n"
        "  SurfacesStandardVertexIntermediate In;\n"
        "  CCSurfacesVertexInput(In);\n"
        "  CCSurfacesVertexAnimation(In);\n"
        "  In.position.xyz = SurfacesVertexModifyLocalPos(In);\n"
        "  SurfacesVertexModifyLocalSharedData(In);\n"
        "  CCSurfacesVertexWorldTransform(In);\n"
        "  In.worldPos = SurfacesVertexModifyWorldPos(In);\n"
        "  In.clipPos = cc_matLightViewProj * vec4(In.worldPos, 1.0);\n"
        "  In.clipPos = SurfacesVertexModifyClipPos(In);\n"
        "  SurfacesVertexModifyUV(In);\n"
        "  SurfacesVertexModifySharedData(In);\n"
        "  CCSurfacesVertexTransformUV(In);\n"
        "  CCSurfacesVertexOutput(In);\n"
        "  v_clip_depth = In.clipPos.zw;\n"
        "}\0";

const char* fragmentShaderSource0 =
        "#version 300 es\n"
        "#define CC_DEVICE_SUPPORT_FLOAT_TEXTURE 1\n"
        "#define CC_DEVICE_MAX_VERTEX_UNIFORM_VECTORS 1024\n"
        "#define CC_DEVICE_MAX_FRAGMENT_UNIFORM_VECTORS 1024\n"
        "#define CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT 0\n"
        "#define CC_PLATFORM_ANDROID_AND_WEBGL 0\n"
        "#define CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES 0\n"
        "#define CC_JOINT_UNIFORM_CAPACITY 256\n"
        "#define CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS 97\n"
        "#define CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS 127\n"
        "#define HAS_SECOND_UV 0\n"
        "#define USE_TWOSIDE 0\n"
        "#define IS_ANISOTROPY 0\n"
        "#define USE_VERTEX_COLOR 0\n"
        "#define FIX_ANISOTROPIC_ROTATION_MAP 0\n"
        "#define USE_NORMAL_MAP 0\n"
        "#define USE_INSTANCING 0\n"
        "#define CC_USE_LIGHTMAP 0\n"
        "#define CC_USE_SKINNING 0\n"
        "#define CC_USE_BAKED_ANIMATION 0\n"
        "#define CC_RECEIVE_SHADOW 1\n"
        "#define CC_USE_REFLECTION_PROBE 0\n"
        "#define CC_USE_LIGHT_PROBE 0\n"
        "#define CC_USE_MORPH 0\n"
        "#define CC_FORWARD_ADD 0\n"
        "#define CC_USE_FOG 4\n"
        "#define CC_USE_ACCURATE_FOG 0\n"
        "#define CC_MORPH_TARGET_COUNT 2\n"
        "#define CC_MORPH_TARGET_HAS_POSITION 0\n"
        "#define CC_MORPH_TARGET_HAS_NORMAL 0\n"
        "#define CC_MORPH_TARGET_HAS_TANGENT 0\n"
        "#define CC_MORPH_PRECOMPUTED 0\n"
        "#define CC_USE_REAL_TIME_JOINT_TEXTURE 0\n"
        "#define CC_DISABLE_STRUCTURE_IN_FRAGMENT_SHADER 0\n"
        "#define CC_PIPELINE_TYPE 0\n"
        "#define CC_FORCE_FORWARD_SHADING 0\n"
        "#define CC_ENABLE_CLUSTERED_LIGHT_CULLING 0\n"
        "#define CC_SUPPORT_CASCADED_SHADOW_MAP 1\n"
        "#define CC_USE_IBL 2\n"
        "#define CC_USE_DIFFUSEMAP 2\n"
        "#define USE_ALBEDO_MAP 1\n"
        "#define ALBEDO_UV v_uv\n"
        "#define NORMAL_UV v_uv\n"
        "#define DEFAULT_UV v_uv\n"
        "#define USE_PBR_MAP 0\n"
        "#define USE_OCCLUSION_MAP 0\n"
        "#define USE_EMISSIVE_MAP 0\n"
        "#define EMISSIVE_UV v_uv\n"
        "#define USE_ANISOTROPY_MAP 0\n"
        "#define USE_ALPHA_TEST 0\n"
        "#define ALPHA_TEST_CHANNEL a\n"
        "#define CC_SHADOWMAP_USE_LINEAR_DEPTH 0\n"
        "#define CC_SHADOWMAP_FORMAT 0\n"
        "\n"
        "precision highp float;\n"
        "  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n"
        "  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n"
        "  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n"
        "  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n"
        "#if IS_ANISOTROPY || USE_NORMAL_MAP\n"
        "  #define CC_SURFACES_USE_TANGENT_SPACE 1\n"
        "#endif\n"
        "  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n"
        "#ifndef CC_SURFACES_USE_SECOND_UV\n"
        "  #define CC_SURFACES_USE_SECOND_UV 0\n"
        "#endif\n"
        "#ifndef CC_SURFACES_USE_TANGENT_SPACE\n"
        "  #define CC_SURFACES_USE_TANGENT_SPACE 0\n"
        "#endif\n"
        "#ifndef CC_SURFACES_USE_VERTEX_COLOR\n"
        "  #define CC_SURFACES_USE_VERTEX_COLOR 0\n"
        "#endif\n"
        "#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n"
        "  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n"
        "#endif\n"
        "#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n"
        "  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n"
        "#endif\n"
        "#ifndef CC_SURFACES_USE_LIGHT_MAP\n"
        "  #ifdef CC_USE_LIGHTMAP\n"
        "    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n"
        "  #else\n"
        "    #define CC_SURFACES_USE_LIGHT_MAP 0\n"
        "  #endif\n"
        "#endif\n"
        "#ifndef CC_SURFACES_FLIP_UV\n"
        "  #define CC_SURFACES_FLIP_UV 0\n"
        "#endif\n"
        "#ifndef CC_SURFACES_USE_TWO_SIDED\n"
        "  #define CC_SURFACES_USE_TWO_SIDED 0\n"
        "#endif\n"
        "#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n"
        "  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n"
        "#endif\n"
        "#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n"
        "  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n"
        "#endif\n"
        "#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n"
        "  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n"
        "#endif\n"
        "#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n"
        "  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n"
        "#endif\n"
        "#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n"
        "  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n"
        "#endif\n"
        "#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n"
        "  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n"
        "#endif\n"
        "#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n"
        "  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n"
        "#endif\n"
        "#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n"
        "  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n"
        "#endif\n"
        "#ifndef CC_SURFACES_LIGHTING_TRT\n"
        "  #define CC_SURFACES_LIGHTING_TRT 0\n"
        "#endif\n"
        "#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n"
        "  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n"
        "#endif\n"
        "#ifndef CC_SURFACES_LIGHTING_SHEEN\n"
        "  #define CC_SURFACES_LIGHTING_SHEEN 0\n"
        "#endif\n"
        "#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n"
        "  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n"
        "#endif\n"
        "#ifndef CC_SURFACES_LIGHTING_TT\n"
        "  #define CC_SURFACES_LIGHTING_TT 0\n"
        "#endif\n"
        "#ifndef CC_SURFACES_LIGHTING_SSS\n"
        "  #define CC_SURFACES_LIGHTING_SSS 0\n"
        "#endif\n"
        "#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n"
        "  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_SHEEN || CC_SURFACES_LIGHTING_CLEAR_COAT\n"
        "    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n"
        "  #endif\n"
        "#endif\n"
        "#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n"
        "  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n"
        "#endif\n"
        "#ifndef CC_SURFACES_LIGHTING_USE_MULTIPLE_LAYER_BLEND\n"
        "  #if CC_SURFACES_LIGHTING_CLEAR_COAT\n"
        "    #define CC_SURFACES_LIGHTING_USE_MULTIPLE_LAYER_BLEND 1\n"
        "  #endif\n"
        "#endif\n"
        "#ifndef CC_SURFACES_LIGHTING_USE_MULTIPLE_LAYER_BLEND\n"
        "  #define CC_SURFACES_LIGHTING_USE_MULTIPLE_LAYER_BLEND 0\n"
        "#endif\n"
        "#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n"
        "  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n"
        "#endif\n"
        "#define CC_USE_SURFACE_SHADER 1\n"
        "#define QUATER_PI         0.78539816340\n"
        "#define HALF_PI           1.57079632679\n"
        "#define PI                3.14159265359\n"
        "#define PI2               6.28318530718\n"
        "#define PI4               12.5663706144\n"
        "#define INV_QUATER_PI     1.27323954474\n"
        "#define INV_HALF_PI       0.63661977237\n"
        "#define INV_PI            0.31830988618\n"
        "#define INV_PI2           0.15915494309\n"
        "#define INV_PI4           0.07957747155\n"
        "#define EPSILON           1e-6\n"
        "#define EPSILON_LOWP      1e-4\n"
        "#define LOG2              1.442695\n"
        "#define EXP_VALUE         2.71828183\n"
        "#define FP_MAX            65504.0\n"
        "#define FP_SCALE          0.0009765625\n"
        "#define FP_SCALE_INV      1024.0\n"
        "#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n"
        "#define LIGHT_MAP_TYPE_DISABLED 0\n"
        "#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n"
        "#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n"
        "#define REFLECTION_PROBE_TYPE_NONE 0\n"
        "#define REFLECTION_PROBE_TYPE_CUBE 1\n"
        "#define REFLECTION_PROBE_TYPE_PLANAR 2\n"
        "#define REFLECTION_PROBE_TYPE_BLEND 3\n"
        "#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n"
        "#define LIGHT_TYPE_DIRECTIONAL 0.0\n"
        "#define LIGHT_TYPE_SPHERE 1.0\n"
        "#define LIGHT_TYPE_SPOT 2.0\n"
        "#define LIGHT_TYPE_POINT 3.0\n"
        "#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n"
        "#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n"
        "#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n"
        "#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n"
        "#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n"
        "#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n"
        "#define TONE_MAPPING_ACES 0\n"
        "#define TONE_MAPPING_LINEAR 1\n"
        "#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n"
        "#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n"
        "  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n"
        "#endif\n"
        "#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n"
        "  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n"
        "#endif\n"
        "in highp vec3 v_worldPos;\n"
        "in vec4 v_normal;\n"
        "in vec2 v_uv;\n"
        "#if CC_SURFACES_USE_VERTEX_COLOR\n"
        "  in lowp vec4 v_color;\n"
        "#endif\n"
        "#if CC_SURFACES_USE_TANGENT_SPACE\n"
        "  in mediump vec4 v_tangent;\n"
        "#endif\n"
        "#if CC_SURFACES_USE_SECOND_UV\n"
        "  in mediump vec2 v_uv1;\n"
        "#endif\n"
        "#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n"
        "  in mediump vec3 v_luv;\n"
        "#endif\n"
        "#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n"
        "  in mediump vec4 v_shadowBiasAndProbeId;\n"
        "#endif\n"
        "#if CC_USE_REFLECTION_PROBE && USE_INSTANCING\n"
        "  in mediump vec4 v_reflectionProbeData;\n"
        "#endif\n"
        "#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n"
        "  in mediump float v_fogFactor;\n"
        "#endif\n"
        "#if CC_SURFACES_TRANSFER_LOCAL_POS\n"
        "  in highp vec4 v_localPos;\n"
        "#endif\n"
        "#if CC_SURFACES_TRANSFER_CLIP_POS\n"
        "  in highp vec4 v_clipPos;\n"
        "#endif\n"
        "#if CC_USE_LIGHT_PROBE\n"
        "  #if USE_INSTANCING\n"
        "    in mediump vec4 v_sh_linear_const_r;\n"
        "    in mediump vec4 v_sh_linear_const_g;\n"
        "    in mediump vec4 v_sh_linear_const_b;\n"
        "  #endif\n"
        "#endif\n"
        "#define FSInput_worldPos v_worldPos\n"
        "#define FSInput_worldNormal v_normal.xyz\n"
        "#define FSInput_faceSideSign v_normal.w\n"
        "#define FSInput_texcoord v_uv\n"
        "#if CC_SURFACES_USE_VERTEX_COLOR\n"
        "  #define FSInput_vertexColor v_color\n"
        "#else\n"
        "  #define FSInput_vertexColor vec4(1.0)\n"
        "#endif\n"
        "#if CC_SURFACES_USE_TANGENT_SPACE\n"
        "  #define FSInput_worldTangent v_tangent.xyz\n"
        "  #define FSInput_mirrorNormal v_tangent.w\n"
        "#else\n"
        "  #define FSInput_worldTangent vec3(1.0, 1.0, 1.0)\n"
        "  #define FSInput_mirrorNormal 1.0\n"
        "#endif\n"
        "#if CC_SURFACES_USE_SECOND_UV\n"
        "  #define FSInput_texcoord1 v_uv1\n"
        "#else\n"
        "  #define FSInput_texcoord1 vec2(0.0, 0.0)\n"
        "#endif\n"
        "#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n"
        "  #define FSInput_lightMapUV v_luv\n"
        "#endif\n"
        "#if CC_RECEIVE_SHADOW\n"
        "  #define FSInput_shadowBias v_shadowBiasAndProbeId.xy\n"
        "#endif\n"
        "#if CC_USE_REFLECTION_PROBE\n"
        "  #define FSInput_reflectionProbeId v_shadowBiasAndProbeId.z\n"
        "  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n"
        "    #define FSInput_reflectionProbeBlendId v_shadowBiasAndProbeId.w\n"
        "  #endif\n"
        "  #if USE_INSTANCING\n"
        "    #define FSInput_reflectionProbeData v_reflectionProbeData\n"
        "  #endif\n"
        "#endif\n"
        "#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n"
        "  #define FSInput_fogFactor v_fogFactor\n"
        "#endif\n"
        "#if CC_SURFACES_TRANSFER_LOCAL_POS\n"
        "  #define FSInput_localPos v_localPos\n"
        "#endif\n"
        "#if CC_SURFACES_TRANSFER_CLIP_POS\n"
        "  #define FSInput_clipPos v_clipPos\n"
        "#endif\n"
        "layout(std140) uniform CCGlobal {\n"
        "  highp   vec4 cc_time;\n"
        "  mediump vec4 cc_screenSize;\n"
        "  mediump vec4 cc_nativeSize;\n"
        "  mediump vec4 cc_probeInfo;\n"
        "  mediump vec4 cc_debug_view_mode;\n"
        "};\n"
        "layout(std140) uniform CCCamera {\n"
        "  highp   mat4 cc_matView;\n"
        "  highp   mat4 cc_matViewInv;\n"
        "  highp   mat4 cc_matProj;\n"
        "  highp   mat4 cc_matProjInv;\n"
        "  highp   mat4 cc_matViewProj;\n"
        "  highp   mat4 cc_matViewProjInv;\n"
        "  highp   vec4 cc_cameraPos;\n"
        "  mediump vec4 cc_surfaceTransform;\n"
        "  mediump vec4 cc_screenScale;\n"
        "  mediump vec4 cc_exposure;\n"
        "  mediump vec4 cc_mainLitDir;\n"
        "  mediump vec4 cc_mainLitColor;\n"
        "  mediump vec4 cc_ambientSky;\n"
        "  mediump vec4 cc_ambientGround;\n"
        "  mediump vec4 cc_fogColor;\n"
        "  mediump vec4 cc_fogBase;\n"
        "  mediump vec4 cc_fogAdd;\n"
        "  mediump vec4 cc_nearFar;\n"
        "  mediump vec4 cc_viewPort;\n"
        "};\n"
        "#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n"
        "#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n"
        "#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n"
        "#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n"
        "#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n"
        "#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n"
        "#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n"
        "#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n"
        "#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n"
        "#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n"
        "#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n"
        "#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n"
        "#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n"
        "#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n"
        "#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n"
        "#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n"
        "#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n"
        "#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n"
        "#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n"
        "#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n"
        "#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n"
        "#define CC_SURFACES_DEBUG_VIEW_IOR CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n"
        "#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_IOR + 1\n"
        "#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n"
        "#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n"
        "#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n"
        "#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n"
        "#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n"
        "#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n"
        "#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n"
        "#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n"
        "#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n"
        "#define CC_SURFACES_DEBUG_VIEW_FRESNEL CC_SURFACES_DEBUG_VIEW_AO + 1\n"
        "#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_FRESNEL + 1\n"
        "#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE + 1\n"
        "#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR + 1\n"
        "#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE + 1\n"
        "#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR + 1\n"
        "#define CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL + 1\n"
        "#define CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR + 1\n"
        "#define CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR + 1\n"
        "#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL + 1\n"
        "#define IS_DEBUG_VIEW_ENABLE_WITH_CAMERA (cc_surfaceTransform.y != 3.0)\n"
        "#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (UnpackBitFromFloat(cc_debug_view_mode.w, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n"
        "#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (UnpackBitFromFloat(cc_debug_view_mode.w, 7) && IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n"
        "#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n"
        "#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n"
        "#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n"
        "#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n"
        "#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (UnpackBitFromFloat(cc_debug_view_mode.y, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n"
        "#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (UnpackBitFromFloat(cc_debug_view_mode.y, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n"
        "#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (UnpackBitFromFloat(cc_debug_view_mode.y, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n"
        "#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (UnpackBitFromFloat(cc_debug_view_mode.y, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n"
        "#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (UnpackBitFromFloat(cc_debug_view_mode.z, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n"
        "#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (UnpackBitFromFloat(cc_debug_view_mode.z, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n"
        "#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (UnpackBitFromFloat(cc_debug_view_mode.z, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n"
        "#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (UnpackBitFromFloat(cc_debug_view_mode.z, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n"
        "#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL (UnpackBitFromFloat(cc_debug_view_mode.z, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n"
        "#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.z, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n"
        "#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n"
        "#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_2ND_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n"
        "#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT (UnpackBitFromFloat(cc_debug_view_mode.w, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n"
        "#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n"
        "  #if CC_FORWARD_ADD\n"
        "    #if CC_PIPELINE_TYPE == 0\n"
        "      #define LIGHTS_PER_PASS 1\n"
        "    #else\n"
        "      #define LIGHTS_PER_PASS 10\n"
        "    #endif\n"
        "    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n"
        "    layout(std140) uniform CCForwardLight {\n"
        "      highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n"
        "      vec4 cc_lightColor[LIGHTS_PER_PASS];\n"
        "      vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n"
        "      vec4 cc_lightDir[LIGHTS_PER_PASS];\n"
        "      vec4 cc_lightBoundingSizeVS[LIGHTS_PER_PASS];\n"
        "    };\n"
        "    #endif\n"
        "  #endif\n"
        "#endif\n"
        "#if CC_USE_LIGHT_PROBE\n"
        "  #if !USE_INSTANCING\n"
        "    layout(std140) uniform CCSH {\n"
        "      vec4 cc_sh_linear_const_r;\n"
        "      vec4 cc_sh_linear_const_g;\n"
        "      vec4 cc_sh_linear_const_b;\n"
        "      vec4 cc_sh_quadratic_r;\n"
        "      vec4 cc_sh_quadratic_g;\n"
        "      vec4 cc_sh_quadratic_b;\n"
        "      vec4 cc_sh_quadratic_a;\n"
        "    };\n"
        "  #endif\n"
        "#endif\n"
        "layout(std140) uniform CCShadow {\n"
        "  highp mat4 cc_matLightView;\n"
        "  highp mat4 cc_matLightViewProj;\n"
        "  highp vec4 cc_shadowInvProjDepthInfo;\n"
        "  highp vec4 cc_shadowProjDepthInfo;\n"
        "  highp vec4 cc_shadowProjInfo;\n"
        "  mediump vec4 cc_shadowNFLSInfo;\n"
        "  mediump vec4 cc_shadowWHPBInfo;\n"
        "  mediump vec4 cc_shadowLPNNInfo;\n"
        "  lowp vec4 cc_shadowColor;\n"
        "  mediump vec4 cc_planarNDInfo;\n"
        "};\n"
        "#if CC_SUPPORT_CASCADED_SHADOW_MAP\n"
        "  layout(std140) uniform CCCSM {\n"
        "    highp vec4 cc_csmViewDir0[4];\n"
        "    highp vec4 cc_csmViewDir1[4];\n"
        "    highp vec4 cc_csmViewDir2[4];\n"
        "    highp vec4 cc_csmAtlas[4];\n"
        "    highp mat4 cc_matCSMViewProj[4];\n"
        "    highp vec4 cc_csmProjDepthInfo[4];\n"
        "    highp vec4 cc_csmProjInfo[4];\n"
        "    highp vec4 cc_csmSplitsInfo;\n"
        "  };\n"
        "#endif\n"
        "uniform samplerCube cc_environment;\n"
        "#if CC_USE_IBL\n"
        "  #if CC_USE_DIFFUSEMAP\n"
        "    uniform samplerCube cc_diffuseMap;\n"
        "  #endif\n"
        "#endif\n"
        "#if CC_USE_REFLECTION_PROBE\n"
        "  uniform samplerCube cc_reflectionProbeCubemap;\n"
        "  uniform sampler2D cc_reflectionProbePlanarMap;\n"
        "  uniform sampler2D cc_reflectionProbeDataMap;\n"
        "  uniform samplerCube cc_reflectionProbeBlendCubemap;\n"
        "#endif\n"
        "vec4 packDepthToRGBA (float depth) {\n"
        "  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n"
        "  ret = fract(ret);\n"
        "  ret -= vec4(ret.yzw, 0.0) / 255.0;\n"
        "  return ret;\n"
        "}\n"
        "#define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\n"
        "#if defined(CC_USE_METAL) || defined(CC_USE_WGPU)\n"
        "#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y) y = -y\n"
        "#else\n"
        "#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y)\n"
        "#endif\n"
        "float GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n"
        "  float dist = length(viewPos);\n"
        "  return (dist - near) / (far - near);\n"
        "}\n"
        "#if CC_SUPPORT_CASCADED_SHADOW_MAP\n"
        "#endif\n"
        "float CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n"
        "\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n"
        "  viewPos.z += viewSpaceBias;\n"
        "\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n"
        "}\n"
        "float CCGetLinearDepth(vec3 worldPos) {\n"
        "\treturn CCGetLinearDepth(worldPos, 0.0);\n"
        "}\n"
        "#if CC_RECEIVE_SHADOW\n"
        "  uniform highp sampler2D cc_shadowMap;\n"
        "  uniform highp sampler2D cc_spotShadowMap;\n"
        "  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n"
        "  #else\n"
        "  #endif\n"
        "#endif\n"
        "#if CC_USE_FOG != 4\n"
        "#endif\n"
        "#if CC_USE_LIGHT_PROBE\n"
        "  #if CC_USE_LIGHT_PROBE\n"
        "  #endif\n"
        "#endif\n"
        "#if CC_USE_REFLECTION_PROBE\n"
        "  layout(std140) uniform CCLocal {\n"
        "    highp mat4 cc_matWorld;\n"
        "    highp mat4 cc_matWorldIT;\n"
        "    highp vec4 cc_lightingMapUVParam;\n"
        "    highp vec4 cc_localShadowBias;\n"
        "    highp vec4 cc_reflectionProbeData1;\n"
        "    highp vec4 cc_reflectionProbeData2;\n"
        "    highp vec4 cc_reflectionProbeBlendData1;\n"
        "    highp vec4 cc_reflectionProbeBlendData2;\n"
        "  };\n"
        "#endif\n"
        "#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n"
        "  uniform sampler2D cc_lightingMap;\n"
        "#endif\n"
        "layout(std140) uniform Constants {\n"
        "  vec4 tilingOffset;\n"
        "  vec4 albedo;\n"
        "  vec4 albedoScaleAndCutoff;\n"
        "  vec4 pbrParams;\n"
        "  vec4 emissive;\n"
        "  vec4 emissiveScaleParam;\n"
        "  vec4 anisotropyParam;\n"
        "};\n"
        "#if USE_ALBEDO_MAP\n"
        "  uniform sampler2D albedoMap;\n"
        "#endif\n"
        "#if USE_NORMAL_MAP\n"
        "  uniform sampler2D normalMap;\n"
        "#endif\n"
        "#if USE_PBR_MAP\n"
        "  uniform sampler2D pbrMap;\n"
        "#endif\n"
        "#if USE_OCCLUSION_MAP\n"
        "  uniform sampler2D occlusionMap;\n"
        "#endif\n"
        "#if USE_EMISSIVE_MAP\n"
        "  uniform sampler2D emissiveMap;\n"
        "#endif\n"
        "#if IS_ANISOTROPY && USE_ANISOTROPY_MAP\n"
        "  uniform sampler2D anisotropyMap;\n"
        "  uniform sampler2D anisotropyMapNearestFilter;\n"
        "#endif\n"
        "#if USE_ALPHA_TEST\n"
        "#endif\n"
        "#define CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TRANSPARENCY\n"
        "#define CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n"
        "void SurfacesFragmentAlphaClipOnly()\n"
        "{\n"
        "  #if USE_ALPHA_TEST\n"
        "    float alpha = albedo.ALPHA_TEST_CHANNEL;\n"
        "    #if USE_VERTEX_COLOR\n"
        "      alpha *= FSInput_vertexColor.a;\n"
        "    #endif\n"
        "    #if USE_ALBEDO_MAP\n"
        "      alpha = texture(albedoMap, ALBEDO_UV).ALPHA_TEST_CHANNEL;\n"
        "    #endif\n"
        "    if (alpha < albedoScaleAndCutoff.w) discard;\n"
        "  #endif\n"
        "}\n"
        "#define CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\n"
        "#define CC_SURFACES_FRAGMENT_MODIFY_ANISOTROPY_PARAMS\n"
        "#define CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\n"
        "#define CC_SURFACES_FRAGMENT_MODIFY_PBRPARAMS\n"
        "in highp vec2 v_clip_depth;\n"
        "layout(location = 0) out vec4 fragColorX;\n"
        "void main () {\n"
        "#ifdef CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n"
        "  SurfacesFragmentAlphaClipOnly();\n"
        "#endif\n"
        "  highp float clipDepth = v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5;\n"
        "  #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n"
        "    if (IS_SPOT_LIGHT(cc_shadowLPNNInfo.x)) {\n"
        "      clipDepth = CCGetLinearDepth(FSInput_worldPos.xyz);\n"
        "    }\n"
        "  #endif\n"
        "  #if CC_SHADOWMAP_FORMAT == 1\n"
        "    fragColorX = packDepthToRGBA(clipDepth);\n"
        "  #else\n"
        "    fragColorX = vec4(clipDepth, 1.0, 1.0, 1.0);\n"
        "  #endif\n"
        "}\0";
#endif //ANDROIDNDKTRIANGLE_MYSHADER_H
